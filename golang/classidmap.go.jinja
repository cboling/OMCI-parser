{{copyright}}
{{generator_warning}}
package {{package_name}}
{# blank line #}
import (
	"../../omci"
	"errors"
	"fmt"
	"github.com/google/gopacket"
	"math/bits"
)
{# blank line #}
// ManagedEntityInfo provides ManagedEntity information
type ManagedEntityInfo struct {
	//Interface  IManagedEntity
	New        func(params ...ParamData)(IManagedEntity, error)
}
{# blank line #}
// ParamData can be passed to the 'New' function to dictate how the returned
// Managed Entity is created. You should supply either zero or one ParamData
// structure to 'New'.
//
// If No ParamData is passed, the returned Managed Entity can only be used for
// providing validation of other structures. This is commonly done in a packet
// encoder/decoder to assist in that process.
//
// If One ParamData is passed, the returned Managed Entity will be initialized
// with the given values/attributes and then validated. This is commonly done
// when you wish to create an ME for transmission, storage or removal from a
// persistent database, or some other similar purpose.
//
type ParamData struct {
	EntityID 	uint16
	Attributes  []omci.IAttribute
}
{# blank line #}
// CreateME wraps a function that makes it a creator of a Managed Entity
type CreateME func(params ...ParamData)(IManagedEntity, error)
{# blank line #}
var classToManagedEntityMap map[uint16]CreateME
{# blank line #}
func init() {
	// Create mapping of 16-bit managed entity class IDs to ME-type
	classToManagedEntityMap = make(map[uint16]CreateME, {{ classIDs|length }})
 {% for cid, me in classIDs.items() %}
	classToManagedEntityMap[{{ cid }}] = New{{ me.name|camelcase }}
 {%- endfor %}
}
{# blank line #}

func decodeEntityID(params ...ParamData) uint16 {
	if len(params) > 0 {
		return params[0].EntityID
	}
	return 0
}

type IManagedEntity interface {
	Name() string
	ClassID() uint16
	EntityID() uint16
	MessageTypes() []omci.MsgType
	AttributesMask() uint16
	Attributes() []omci.IAttribute
	Decode(uint16, []byte, gopacket.DecodeFeedback) error
	SerializeTo(uint16, gopacket.SerializeBuffer) error
}

type BaseManagedEntity struct {
	name          string
	classID       uint16
	entityID      uint16
	msgTypes      []omci.MsgType
	attributeMask uint16
	attributeList []omci.IAttribute
}

func (bme *BaseManagedEntity) Name() string             	{ return bme.name }
func (bme *BaseManagedEntity) ClassID() uint16          	{ return bme.classID }
func (bme *BaseManagedEntity) EntityID() uint16         	{ return bme.entityID }
func (bme *BaseManagedEntity) MessageTypes() []omci.MsgType { return bme.msgTypes }
func (bme *BaseManagedEntity) AttributesMask() uint16   	{ return bme.attributeMask }
func (bme *BaseManagedEntity) Attributes() []omci.IAttribute{ return bme.attributeList }

func (bme *BaseManagedEntity) String() string {
	return fmt.Sprintf("%v: CID: %v (%#x), EID: %v (%#x), Attributes: %v",
		bme.Name(), bme.ClassID(), bme.ClassID(), bme.EntityID(), bme.EntityID(),
		bme.Attributes())
}

func (bme *BaseManagedEntity) Decode(mask uint16, data []byte, df gopacket.DecodeFeedback) error {
	// Validate attribute mask passed in
	if mask&^bme.attributeMask > 0 {
		return errors.New("invalid attribute mask specified") // Unsupported bits set
	}
	// Loop over possible attributes
	for index := 0; index < bits.OnesCount16(bme.attributeMask); index++ {
		// If bit is set, decode that attribute
		if mask&uint16(1<<(15-uint(index))) > 0 {
			// Pull from list
			attribute := bme.attributeList[index]

			// decode & advance data slice if success
			err := attribute.DecodeFromBytes(data, df)
			if err != nil {
				return err
			}
			data = data[attribute.Size():]
		}
	}
	return nil
}

func (bme *BaseManagedEntity) SerializeTo(mask uint16, b gopacket.SerializeBuffer) error {
	// Validate attribute mask passed in
	if mask&^bme.attributeMask > 0 {
		return errors.New("invalid attribute mask specified") // Unsupported bits set
	}
	// Loop over possible attributes
	for index := 0; index < bits.OnesCount16(bme.attributeMask); index++ {
		// If bit is set, decode that attribute
		if mask&uint16(1<<(15-uint(index))) > 0 {
			// Pull from list
			attribute := bme.attributeList[index]

			// encode
			err := attribute.SerializeTo(b)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (bme *BaseManagedEntity) computeAttributeMask() {
	for index := range bme.Attributes() {
		bme.attributeMask |= 1 << (15 - uint(index))
	}
}
